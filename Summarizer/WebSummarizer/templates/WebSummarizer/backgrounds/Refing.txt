Данные процессы затем выполнялись независимо и использовали блокирующие сокеты.
Данные процессы затем выполнялись независимо и использовали блокирующие сокеты.
Блокирующие сокеты намного лучше для поточности, безопасности и по другим аспектам.
Блокирующие сокеты намного лучше для поточности, безопасности и по другим аспектам.
3.5.ДОСТОИНСТВА БЛОКИРУЮЩЕГО РЕЖИМА 1.Проще программировать - Блокирующие сокеты проще программировать.
3.5.ДОСТОИНСТВА БЛОКИРУЮЩЕГО РЕЖИМА 1.Проще программировать - Блокирующие сокеты проще программировать.
2.Кросс-платформенность – поскольку Unix использует блокирующие сокеты, то переносимый код легче писать.
2.Кросс-платформенность – поскольку Unix использует блокирующие сокеты, то переносимый код легче писать.
4.Независимость от сообщений – неблокирующие сокеты зависят от системы оконных сообщений.
4.Независимость от сообщений – неблокирующие сокеты зависят от системы оконных сообщений.
1.Более сложное программирование – неблокирующие сокеты требуют использования опроса или обработки событий.
1.Более сложное программирование – неблокирующие сокеты требуют использования опроса или обработки событий.
Code: procedure TForm1.Button1Click(Sender: TObject); begin File1.Filename := 'd:\temp\test.dat'; File1.Open; end; procedure TForm1.File1OnOpen(Sender: TObject); var i: integer; begin FWriteData := 'Hello World!'+ #13#10; i := File1.Write(FWriteData); Delete(FWriteData, 1, i); end; procedure TForm1.File1OnWrite(Sender: TObject); var i: integer; begin i := File1.Write(FWriteData); Delete(FWriteData, 1, i); if Length(FWriteData) = 0 then  begin    File1.Close; end; end; procedure TForm1.File1OnClose(Sender: TObject); begin Button1.Enabled := True; end;     Потратим немного времени, что бы попытаться понять, что здесь делается.Если вы используете неблокирующие сокеты, то вы должны легко понимать данный код.
Code: procedure TForm1.Button1Click(Sender: TObject); begin File1.Filename := 'd:\temp\test.dat'; File1.Open; end; procedure TForm1.File1OnOpen(Sender: TObject); var i: integer; begin FWriteData := 'Hello World!'+ #13#10; i := File1.Write(FWriteData); Delete(FWriteData, 1, i); end; procedure TForm1.File1OnWrite(Sender: TObject); var i: integer; begin i := File1.Write(FWriteData); Delete(FWriteData, 1, i); if Length(FWriteData) = 0 then  begin    File1.Close; end; end; procedure TForm1.File1OnClose(Sender: TObject); begin Button1.Enabled := True; end;     Потратим немного времени, что бы попытаться понять, что здесь делается.Если вы используете неблокирующие сокеты, то вы должны легко понимать данный код.
 Блокирующие сокеты [13] создают некоторые неудобства, потому что вызов любой из Winsock-API-функций блокируют главный поток на некоторое время.
 Блокирующие сокеты [13] создают некоторые неудобства, потому что вызов любой из Winsock-API-функций блокируют главный поток на некоторое время.
Блокирующие сокеты более легки в использовании с концептуальной точки зрения, но есть затруднения в управлении большого количества соединений, либо когда передаются данные разных обьемов и в разные периоды времени.
Блокирующие сокеты более легки в использовании с концептуальной точки зрения, но есть затруднения в управлении большого количества соединений, либо когда передаются данные разных обьемов и в разные периоды времени.
С другой стороны неблокирующие сокеты более сложны, так как существует необходимость в написание более сложного кода для управления возможностью приема кодов возврата типа WSAEWOULDBLOCK при каждом вызове Winsock API функций.
С другой стороны неблокирующие сокеты более сложны, так как существует необходимость в написание более сложного кода для управления возможностью приема кодов возврата типа WSAEWOULDBLOCK при каждом вызове Winsock API функций.
